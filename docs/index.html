<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒ—äº¬æ™ºèƒ½å‡ºè¡Œå†³ç­–åŠ©æ‰‹</title>
    <meta name="description" content="åŸºäºå®æ—¶è·¯å†µçš„åŒ—äº¬å‡ºè¡Œè·¯çº¿è§„åˆ’å·¥å…·">
    <script src="https://webapi.amap.com/maps?v=2.0&key=12c7f133b9e4a7fa4933479eb20ad90e&plugin=AMap.AutoComplete,AMap.PlaceSearch,AMap.Driving,AMap.Transfer"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
        }

        .sidebar {
            background: #000000;
            color: #ffffff;
            padding: 30px;
            overflow-y: auto;
            border-right: 3px solid #000000;
        }

        .header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #ffffff;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 12px;
            opacity: 0.7;
            letter-spacing: 1px;
        }

        .status-section {
            background: #ffffff;
            color: #000000;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px solid #000000;
        }

        .status-title {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #cccccc;
            border-radius: 0;
        }

        .status-dot.online {
            background: #000000;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .input-wrapper {
            position: relative;
        }

        input, select {
            width: 100%;
            padding: 12px;
            background: #ffffff;
            color: #000000;
            border: 2px solid #ffffff;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #cccccc;
        }

        .autocomplete-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #ffffff;
            border: 2px solid #000000;
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .autocomplete-results.show {
            display: block;
        }

        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid #eeeeee;
            color: #000000;
        }

        .autocomplete-item:hover {
            background: #000000;
            color: #ffffff;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .btn-primary {
            width: 100%;
            padding: 15px;
            background: #ffffff;
            color: #000000;
            border: 2px solid #ffffff;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary:hover {
            background: #000000;
            color: #ffffff;
            border: 2px solid #ffffff;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .results-section {
            margin-top: 20px;
            padding: 20px;
            background: #ffffff;
            color: #000000;
            border: 2px solid #ffffff;
            display: none;
        }

        .results-section.show {
            display: block;
        }

        .result-title {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .recommendation {
            background: #000000;
            color: #ffffff;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #000000;
        }

        .recommendation-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .recommendation-reason {
            font-size: 13px;
            line-height: 1.8;
            opacity: 0.9;
            margin-bottom: 15px;
        }

        .route-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .route-item {
            padding: 15px;
            background: #ffffff;
            color: #000000;
            border: 2px solid #ffffff;
        }

        .route-item.recommended {
            border-color: #000000;
            border-width: 3px;
        }

        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #cccccc;
        }

        .route-type {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .route-cost {
            font-size: 16px;
            font-weight: 700;
        }

        .route-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 12px;
        }

        .route-detail {
            text-align: left;
        }

        .detail-label {
            opacity: 0.7;
            margin-bottom: 4px;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }

        .detail-value {
            font-weight: 700;
            font-size: 14px;
        }

        .map-container {
            background: #f5f5f5;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .error-message {
            background: #000000;
            color: #ffffff;
            padding: 15px;
            margin-top: 15px;
            border: 2px solid #000000;
            font-size: 13px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 8px;
        }

        .badge.recommended {
            background: #000000;
            color: #ffffff;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }

            .sidebar {
                height: auto;
                max-height: 50vh;
            }

            .route-comparison {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1>åŒ—äº¬æ™ºèƒ½å‡ºè¡Œ</h1>
                <p class="subtitle">BEIJING COMMUTE OPTIMIZER</p>
            </div>

            <div class="status-section">
                <div class="status-title">System Status</div>
                <div class="status-indicator">
                    <div class="status-dot" id="status-dot"></div>
                    <span id="status-text">æ£€æŸ¥ä¸­...</span>
                </div>
            </div>

            <form id="route-form">
                <div class="form-group">
                    <label>èµ·ç‚¹ / Start</label>
                    <div class="input-wrapper">
                        <input type="text" id="start-input" placeholder="è¾“å…¥èµ·ç‚¹ä½ç½®..." required autocomplete="off">
                        <div class="autocomplete-results" id="start-results"></div>
                    </div>
                </div>

                <div class="form-group">
                    <label>ç»ˆç‚¹ / End</label>
                    <div class="input-wrapper">
                        <input type="text" id="end-input" placeholder="è¾“å…¥ç»ˆç‚¹ä½ç½®..." required autocomplete="off">
                        <div class="autocomplete-results" id="end-results"></div>
                    </div>
                </div>

                <button type="submit" class="btn-primary" id="submit-btn">
                    æ™ºèƒ½å†³ç­– / Smart Decision
                </button>
            </form>

            <div id="error-message" class="error-message"></div>

            <div id="results-section" class="results-section">
                <div class="result-title">å†³ç­–ç»“æœ / Decision</div>
                <div id="results-content"></div>
            </div>
        </div>

        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <script>
        const API_URL = 'https://beijing-commute-isbgwcfmkn.cn-hangzhou.fcapp.run';
        const AMAP_KEY = '12c7f133b9e4a7fa4933479eb20ad90e';

        let map;
        let startMarker, endMarker;
        let startLocation, endLocation;
        let autoCompleteStart, autoCompleteEnd;
        let drivingService, transitService;

        // åˆå§‹åŒ–åœ°å›¾
        function initMap() {
            map = new AMap.Map('map', {
                zoom: 11,
                center: [116.397428, 39.90923],
                mapStyle: 'amap://styles/whitesmoke'
            });

            // åˆå§‹åŒ–è‡ªåŠ¨å®Œæˆ
            autoCompleteStart = new AMap.AutoComplete({
                city: 'åŒ—äº¬'
            });

            autoCompleteEnd = new AMap.AutoComplete({
                city: 'åŒ—äº¬'
            });

            // åˆå§‹åŒ–è·¯çº¿æœåŠ¡
            drivingService = new AMap.Driving({
                policy: 0 // ç»¼åˆæœ€ä¼˜
            });

            transitService = new AMap.Transfer({
                city: 'åŒ—äº¬'
            });

            console.log('Map initialized successfully');

            // åœ°å›¾åˆå§‹åŒ–å®Œæˆå,è®¾ç½®è‡ªåŠ¨å®Œæˆ
            setupAutocomplete('start-input', 'start-results', autoCompleteStart);
            setupAutocomplete('end-input', 'end-results', autoCompleteEnd);
        }

        // æ£€æŸ¥æœåŠ¡çŠ¶æ€
        async function checkStatus() {
            const statusText = document.getElementById('status-text');
            const statusDot = document.getElementById('status-dot');

            try {
                const response = await fetch(API_URL);
                const data = await response.json();

                if (data.status === 'ok') {
                    statusText.textContent = 'æœåŠ¡æ­£å¸¸';
                    statusDot.classList.add('online');
                    console.log('API status OK');
                } else {
                    statusText.textContent = 'æœåŠ¡å¼‚å¸¸';
                    statusDot.classList.remove('online');
                }
            } catch (error) {
                statusText.textContent = 'è¿æ¥å¤±è´¥';
                statusDot.classList.remove('online');
                console.error('Status check failed:', error);
            }
        }

        // åœ°ç‚¹æœç´¢è”æƒ³
        function setupAutocomplete(inputId, resultsId, autocompleteInstance) {
            const input = document.getElementById(inputId);
            const results = document.getElementById(resultsId);

            input.addEventListener('input', function() {
                const keyword = this.value.trim();

                if (keyword.length < 2) {
                    results.classList.remove('show');
                    return;
                }

                autocompleteInstance.search(keyword, function(status, result) {
                    console.log('Autocomplete status:', status, 'result:', result);
                    if (status === 'complete' && result.tips) {
                        displayResults(result.tips, results, input, inputId === 'start-input' ? 'start' : 'end');
                    } else {
                        results.classList.remove('show');
                    }
                });
            });

            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !results.contains(e.target)) {
                    results.classList.remove('show');
                }
            });
        }

        function displayResults(tips, resultsContainer, inputElement, type) {
            if (!tips || tips.length === 0) {
                resultsContainer.classList.remove('show');
                return;
            }

            resultsContainer.innerHTML = tips.slice(0, 5).map(tip => {
                if (!tip.location) return '';
                return `
                    <div class="autocomplete-item" data-lng="${tip.location.lng}" data-lat="${tip.location.lat}" data-name="${tip.name}">
                        ${tip.name} ${tip.district ? '- ' + tip.district : ''}
                    </div>
                `;
            }).filter(item => item !== '').join('');

            resultsContainer.classList.add('show');

            resultsContainer.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', function() {
                    const name = this.dataset.name;
                    const lng = parseFloat(this.dataset.lng);
                    const lat = parseFloat(this.dataset.lat);

                    inputElement.value = name;

                    if (type === 'start') {
                        startLocation = { name, lng, lat };
                        updateMarker('start', lng, lat);
                    } else {
                        endLocation = { name, lng, lat };
                        updateMarker('end', lng, lat);
                    }

                    resultsContainer.classList.remove('show');

                    if (startLocation && endLocation) {
                        map.setFitView([startMarker, endMarker]);
                    }
                });
            });
        }

        function updateMarker(type, lng, lat) {
            const position = [lng, lat];

            if (type === 'start') {
                if (startMarker) {
                    startMarker.setPosition(position);
                } else {
                    startMarker = new AMap.Marker({
                        position: position,
                        title: 'èµ·ç‚¹',
                        label: { content: 'A', direction: 'top' }
                    });
                    map.add(startMarker);
                }
            } else {
                if (endMarker) {
                    endMarker.setPosition(position);
                } else {
                    endMarker = new AMap.Marker({
                        position: position,
                        title: 'ç»ˆç‚¹',
                        label: { content: 'B', direction: 'top' }
                    });
                    map.add(endMarker);
                }
            }

            map.setCenter(position);
        }

        // æ˜¾ç¤ºé”™è¯¯
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => errorDiv.classList.remove('show'), 5000);
        }

        // æ··åˆæ–¹æ¡ˆæ™ºèƒ½å†³ç­–ç®—æ³•
        async function findOptimalMixedRoute(transitData) {
            // æå–åœ°é“è·¯çº¿ä¸­çš„å…³é”®ç«™ç‚¹
            const stations = extractKeyStations(transitData.plan);
            const mixedRoutes = [];

            // æµ‹è¯•ä¸åŒçš„æ··åˆæ–¹æ¡ˆ
            for (const station of stations) {
                try {
                    // æ–¹æ¡ˆ1: æ‰“è½¦åˆ°è¯¥ç«™ + åœ°é“åˆ°ç»ˆç‚¹
                    const taxiToStation = await getDrivingRouteBetween(startLocation, station);
                    const transitFromStation = await getTransitRouteBetween(station, endLocation);

                    if (taxiToStation && transitFromStation) {
                        mixedRoutes.push({
                            type: 'taxi-transit',
                            station: station.name,
                            segments: [taxiToStation, transitFromStation],
                            totalTime: (taxiToStation.time + transitFromStation.time) / 60,
                            totalCost: taxiToStation.cost + transitFromStation.cost
                        });
                    }

                    // æ–¹æ¡ˆ2: åœ°é“åˆ°è¯¥ç«™ + æ‰“è½¦åˆ°ç»ˆç‚¹
                    const transitToStation = await getTransitRouteBetween(startLocation, station);
                    const taxiFromStation = await getDrivingRouteBetween(station, endLocation);

                    if (transitToStation && taxiFromStation) {
                        mixedRoutes.push({
                            type: 'transit-taxi',
                            station: station.name,
                            segments: [transitToStation, taxiFromStation],
                            totalTime: (transitToStation.time + taxiFromStation.time) / 60,
                            totalCost: transitToStation.cost + taxiFromStation.cost
                        });
                    }
                } catch (e) {
                    console.log('Mixed route calculation failed for station:', station.name, e);
                }
            }

            return mixedRoutes;
        }

        // æå–åœ°é“æ–¹æ¡ˆä¸­çš„å…³é”®ç«™ç‚¹
        function extractKeyStations(plan) {
            const stations = [];

            plan.segments.forEach(segment => {
                if (segment.transit && segment.transit.name) {
                    // æå–åœ°é“ç«™ç‚¹
                    const stationName = segment.transit.departure_stop || segment.transit.name;
                    const coords = segment.start_location;

                    if (coords && stationName) {
                        stations.push({
                            name: stationName,
                            lng: coords.lng,
                            lat: coords.lat
                        });
                    }
                }
            });

            // åªä¿ç•™å‰3ä¸ªå’Œå3ä¸ªç«™ç‚¹é¿å…è®¡ç®—é‡è¿‡å¤§
            return [...stations.slice(0, 3), ...stations.slice(-3)];
        }

        // è·å–ä¸¤ç‚¹é—´çš„æ‰“è½¦è·¯çº¿
        function getDrivingRouteBetween(start, end) {
            return new Promise((resolve, reject) => {
                const driving = new AMap.Driving({ policy: 0 });
                driving.search(
                    [start.lng, start.lat],
                    [end.lng, end.lat],
                    function(status, result) {
                        if (status === 'complete' && result.routes && result.routes.length > 0) {
                            const route = result.routes[0];
                            resolve({
                                time: route.time,
                                distance: route.distance,
                                cost: Math.round(route.distance / 1000 * 3.5),
                                type: 'driving'
                            });
                        } else {
                            resolve(null);
                        }
                    }
                );
            });
        }

        // è·å–ä¸¤ç‚¹é—´çš„åœ°é“è·¯çº¿
        function getTransitRouteBetween(start, end) {
            return new Promise((resolve, reject) => {
                const transit = new AMap.Transfer({ city: 'åŒ—äº¬' });
                transit.search(
                    [start.lng, start.lat],
                    [end.lng, end.lat],
                    function(status, result) {
                        if (status === 'complete' && result.plans && result.plans.length > 0) {
                            const plan = result.plans[0];
                            resolve({
                                time: plan.time,
                                distance: plan.distance,
                                cost: plan.cost || 3,
                                type: 'transit'
                            });
                        } else {
                            resolve(null);
                        }
                    }
                );
            });
        }

        // æ™ºèƒ½å†³ç­–ç®—æ³•(åŒ…å«æ··åˆæ–¹æ¡ˆ)
        function makeSmartDecision(drivingData, transitData, mixedRoutes = []) {
            // å†³ç­–æƒé‡é…ç½®
            const weights = {
                time: 0.4,      // æ—¶é—´æƒé‡40%
                cost: 0.35,     // è´¹ç”¨æƒé‡35%
                comfort: 0.25   // èˆ’é€‚åº¦æƒé‡25%
            };

            // è®¡ç®—ç»¼åˆå¾—åˆ†
            function calculateScore(time, cost, comfort) {
                const timeScore = Math.max(0, 100 - time * 2);
                const costScore = Math.max(0, 100 - cost / 2);
                return timeScore * weights.time + costScore * weights.cost + comfort * weights.comfort;
            }

            // æ‰€æœ‰æ–¹æ¡ˆ
            const allOptions = [
                {
                    type: 'driving',
                    time: drivingData.time / 60,
                    cost: drivingData.cost,
                    comfort: 80,
                    data: drivingData
                },
                {
                    type: 'transit',
                    time: transitData.time / 60,
                    cost: transitData.cost,
                    comfort: 60,
                    data: transitData
                },
                ...mixedRoutes.map(route => ({
                    type: 'mixed',
                    subtype: route.type,
                    station: route.station,
                    time: route.totalTime,
                    cost: route.totalCost,
                    comfort: 70, // æ··åˆæ–¹æ¡ˆèˆ’é€‚åº¦ä»‹äºä¸¤è€…ä¹‹é—´
                    data: route
                }))
            ];

            // è®¡ç®—æ¯ä¸ªæ–¹æ¡ˆçš„å¾—åˆ†
            allOptions.forEach(opt => {
                opt.score = calculateScore(opt.time, opt.cost, opt.comfort);
            });

            // æ’åºæ‰¾å‡ºæœ€ä¼˜æ–¹æ¡ˆ
            allOptions.sort((a, b) => b.score - a.score);
            const best = allOptions[0];

            // ç”Ÿæˆæ¨èç†ç”±
            let reason = '';
            let recommended = best.type;

            if (best.type === 'mixed') {
                if (best.subtype === 'taxi-transit') {
                    reason = `æ¨èæ··åˆå‡ºè¡Œï¼šå…ˆæ‰“è½¦åˆ°${best.station}ï¼Œç„¶åæ¢ä¹˜åœ°é“ã€‚æ€»æ—¶é—´${Math.round(best.time)}åˆ†é’Ÿï¼Œè´¹ç”¨Â¥${Math.round(best.cost)}ï¼Œæ€§ä»·æ¯”æœ€ä¼˜ã€‚`;
                } else {
                    reason = `æ¨èæ··åˆå‡ºè¡Œï¼šå…ˆä¹˜åœ°é“åˆ°${best.station}ï¼Œç„¶åæ‰“è½¦ã€‚æ€»æ—¶é—´${Math.round(best.time)}åˆ†é’Ÿï¼Œè´¹ç”¨Â¥${Math.round(best.cost)}ï¼Œæ€§ä»·æ¯”æœ€ä¼˜ã€‚`;
                }
                recommended = 'mixed';
            } else if (best.type === 'driving') {
                const transitOption = allOptions.find(o => o.type === 'transit');
                const timeDiff = Math.round(transitOption.time - best.time);
                const costDiff = Math.round(best.cost - transitOption.cost);

                if (timeDiff > 20) {
                    reason = `æ¨èæ‰“è½¦ã€‚è™½ç„¶è´¹ç”¨å¤š Â¥${costDiff}ï¼Œä½†å¯èŠ‚çœ ${timeDiff} åˆ†é’Ÿï¼Œæ€§ä»·æ¯”æ›´é«˜ã€‚`;
                } else if (costDiff < 30) {
                    reason = `æ¨èæ‰“è½¦ã€‚è´¹ç”¨ä»…å¤š Â¥${costDiff}ï¼Œä½†æ›´åŠ èˆ’é€‚ä¾¿æ·ï¼Œæ— éœ€æ¢ä¹˜ã€‚`;
                } else {
                    reason = `æ¨èæ‰“è½¦ã€‚ç»¼åˆæ—¶é—´ã€è´¹ç”¨å’Œèˆ’é€‚åº¦ï¼Œæ‰“è½¦æ˜¯æ›´ä¼˜é€‰æ‹©ã€‚`;
                }
            } else {
                const drivingOption = allOptions.find(o => o.type === 'driving');
                const timeDiff = Math.round(drivingOption.time - best.time);
                const costDiff = Math.round(drivingOption.cost - best.cost);

                if (costDiff > 50) {
                    reason = `æ¨èåœ°é“ã€‚å¯èŠ‚çœ Â¥${costDiff}ï¼Œç»æµå®æƒ ã€‚${timeDiff > 0 ? `æ—¶é—´ä»…å¤š ${timeDiff} åˆ†é’Ÿã€‚` : ''}`;
                } else if (best.time < drivingOption.time) {
                    reason = `æ¨èåœ°é“ã€‚èŠ‚çœ ${timeDiff} åˆ†é’Ÿï¼Œä¸”è´¹ç”¨æ›´ä½ï¼Œæ˜¯æœ€ä¼˜é€‰æ‹©ã€‚`;
                } else {
                    reason = `æ¨èåœ°é“ã€‚è™½ç„¶æ—¶é—´ç•¥é•¿ï¼Œä½†è´¹ç”¨ä½å»‰ï¼Œé€‚åˆæ—¥å¸¸é€šå‹¤ã€‚`;
                }
            }

            return {
                recommended,
                reason,
                bestOption: best,
                allOptions
            };
        }

        // è§„åˆ’è·¯çº¿å¹¶è¿›è¡Œæ™ºèƒ½å†³ç­–
        async function planRoute(e) {
            e.preventDefault();

            if (!startLocation || !endLocation) {
                showError('è¯·å…ˆé€‰æ‹©èµ·ç‚¹å’Œç»ˆç‚¹');
                return;
            }

            const submitBtn = document.getElementById('submit-btn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'æ™ºèƒ½åˆ†æä¸­...';

            // æ¸…é™¤ä¹‹å‰çš„è·¯çº¿
            map.clearMap();

            // é‡æ–°æ·»åŠ æ ‡è®°
            if (startMarker) map.add(startMarker);
            if (endMarker) map.add(endMarker);

            try {
                // å¹¶è¡Œè·å–æ‰“è½¦å’Œåœ°é“æ–¹æ¡ˆ
                const [drivingResult, transitResult] = await Promise.all([
                    getDrivingRoute(),
                    getTransitRoute()
                ]);

                console.log('Driving result:', drivingResult);
                console.log('Transit result:', transitResult);

                // è®¡ç®—æ··åˆæ–¹æ¡ˆ
                submitBtn.textContent = 'è®¡ç®—æ··åˆæ–¹æ¡ˆ...';
                const mixedRoutes = await findOptimalMixedRoute(transitResult);
                console.log('Mixed routes:', mixedRoutes);

                // è¿›è¡Œæ™ºèƒ½å†³ç­–
                const decision = makeSmartDecision(drivingResult, transitResult, mixedRoutes);

                // æ˜¾ç¤ºç»“æœ
                displayDecision(decision, drivingResult, transitResult, mixedRoutes);

                // ç»˜åˆ¶æ¨èè·¯çº¿
                if (decision.recommended === 'driving') {
                    drawDrivingRoute(drivingResult.route);
                } else if (decision.recommended === 'transit') {
                    drawTransitRoute(transitResult.plan);
                } else if (decision.recommended === 'mixed') {
                    // ç»˜åˆ¶æ··åˆè·¯çº¿
                    drawMixedRoute(decision.bestOption.data);
                }

            } catch (error) {
                console.error('Route planning error:', error);
                showError('è·¯çº¿è§„åˆ’å¤±è´¥: ' + error.message);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'æ™ºèƒ½å†³ç­– / Smart Decision';
            }
        }

        function getDrivingRoute() {
            return new Promise((resolve, reject) => {
                drivingService.search(
                    [startLocation.lng, startLocation.lat],
                    [endLocation.lng, endLocation.lat],
                    function(status, result) {
                        if (status === 'complete' && result.routes && result.routes.length > 0) {
                            const route = result.routes[0];
                            resolve({
                                time: route.time,
                                distance: route.distance,
                                cost: route.tolls || Math.round(route.distance / 1000 * 3.5), // æŒ‰3.5å…ƒ/å…¬é‡Œä¼°ç®—
                                route: route
                            });
                        } else {
                            reject(new Error('æ‰“è½¦è·¯çº¿è§„åˆ’å¤±è´¥'));
                        }
                    }
                );
            });
        }

        function getTransitRoute() {
            return new Promise((resolve, reject) => {
                transitService.search(
                    [startLocation.lng, startLocation.lat],
                    [endLocation.lng, endLocation.lat],
                    function(status, result) {
                        if (status === 'complete' && result.plans && result.plans.length > 0) {
                            const plan = result.plans[0];
                            resolve({
                                time: plan.time,
                                distance: plan.distance,
                                cost: plan.cost || 3, // é»˜è®¤3å…ƒ
                                plan: plan
                            });
                        } else {
                            reject(new Error('åœ°é“è·¯çº¿è§„åˆ’å¤±è´¥'));
                        }
                    }
                );
            });
        }

        function displayDecision(decision, drivingData, transitData, mixedRoutes = []) {
            const resultsSection = document.getElementById('results-section');
            const resultsContent = document.getElementById('results-content');

            const drivingTime = Math.round(drivingData.time / 60);
            const drivingDistance = (drivingData.distance / 1000).toFixed(1);
            const drivingCost = drivingData.cost;

            const transitTime = Math.round(transitData.time / 60);
            const transitDistance = (transitData.distance / 1000).toFixed(1);
            const transitCost = transitData.cost;

            // æ¨èæ ‡é¢˜å’Œå›¾æ ‡
            let recommendTitle = '';
            if (decision.recommended === 'mixed') {
                recommendTitle = 'ğŸš—ğŸš‡ æ¨èæ··åˆå‡ºè¡Œ';
            } else if (decision.recommended === 'driving') {
                recommendTitle = 'ğŸš— æ¨èæ‰“è½¦';
            } else {
                recommendTitle = 'ğŸš‡ æ¨èåœ°é“';
            }

            const html = `
                <div class="recommendation">
                    <div class="recommendation-title">
                        ${recommendTitle}
                    </div>
                    <div class="recommendation-reason">
                        ${decision.reason}
                    </div>
                </div>

                <div class="route-comparison">
                    <div class="route-item ${decision.recommended === 'driving' ? 'recommended' : ''}">
                        <div class="route-header">
                            <span class="route-type">
                                æ‰“è½¦ / Taxi
                                ${decision.recommended === 'driving' ? '<span class="badge recommended">æ¨è</span>' : ''}
                            </span>
                            <span class="route-cost">Â¥ ${drivingCost}</span>
                        </div>
                        <div class="route-details">
                            <div class="route-detail">
                                <div class="detail-label">æ—¶é—´</div>
                                <div class="detail-value">${drivingTime}åˆ†é’Ÿ</div>
                            </div>
                            <div class="route-detail">
                                <div class="detail-label">è·ç¦»</div>
                                <div class="detail-value">${drivingDistance}å…¬é‡Œ</div>
                            </div>
                        </div>
                    </div>

                    <div class="route-item ${decision.recommended === 'transit' ? 'recommended' : ''}">
                        <div class="route-header">
                            <span class="route-type">
                                åœ°é“ / Metro
                                ${decision.recommended === 'transit' ? '<span class="badge recommended">æ¨è</span>' : ''}
                            </span>
                            <span class="route-cost">Â¥ ${transitCost}</span>
                        </div>
                        <div class="route-details">
                            <div class="route-detail">
                                <div class="detail-label">æ—¶é—´</div>
                                <div class="detail-value">${transitTime}åˆ†é’Ÿ</div>
                            </div>
                            <div class="route-detail">
                                <div class="detail-label">è·ç¦»</div>
                                <div class="detail-value">${transitDistance}å…¬é‡Œ</div>
                            </div>
                        </div>
                    </div>
                </div>

                ${decision.recommended === 'mixed' && decision.bestOption ? `
                    <div style="margin-top: 15px; padding: 15px; background: #f5f5f5; border: 2px solid #000000;">
                        <div style="font-size: 11px; font-weight: 700; letter-spacing: 1px; margin-bottom: 10px; text-transform: uppercase;">
                            æ··åˆæ–¹æ¡ˆè¯¦æƒ…
                        </div>
                        <div style="font-size: 13px; line-height: 1.6;">
                            ${decision.bestOption.subtype === 'taxi-transit'
                                ? `<strong>ç¬¬ä¸€æ®µ:</strong> æ‰“è½¦åˆ° ${decision.bestOption.station}<br>
                                   <strong>ç¬¬äºŒæ®µ:</strong> ä¹˜åœ°é“åˆ°ç»ˆç‚¹`
                                : `<strong>ç¬¬ä¸€æ®µ:</strong> ä¹˜åœ°é“åˆ° ${decision.bestOption.station}<br>
                                   <strong>ç¬¬äºŒæ®µ:</strong> æ‰“è½¦åˆ°ç»ˆç‚¹`
                            }
                            <br><br>
                            <strong>æ€»æ—¶é—´:</strong> ${Math.round(decision.bestOption.time)}åˆ†é’Ÿ<br>
                            <strong>æ€»è´¹ç”¨:</strong> Â¥${Math.round(decision.bestOption.cost)}
                        </div>
                    </div>
                ` : ''}
            `;

            resultsContent.innerHTML = html;
            resultsSection.classList.add('show');
        }

        function drawDrivingRoute(route) {
            const path = [];
            route.steps.forEach(step => {
                step.path.forEach(point => {
                    path.push([point.lng, point.lat]);
                });
            });

            const polyline = new AMap.Polyline({
                path: path,
                strokeColor: '#000000',
                strokeWeight: 5,
                strokeOpacity: 0.8
            });

            map.add(polyline);
            map.setFitView([polyline, startMarker, endMarker]);
        }

        function drawTransitRoute(plan) {
            const allPaths = [];

            plan.segments.forEach(segment => {
                if (segment.transit_mode === 'WALK') {
                    const path = segment.path.map(p => [p.lng, p.lat]);
                    const polyline = new AMap.Polyline({
                        path: path,
                        strokeColor: '#666666',
                        strokeWeight: 3,
                        strokeStyle: 'dashed'
                    });
                    map.add(polyline);
                    allPaths.push(polyline);
                } else {
                    const path = segment.path.map(p => [p.lng, p.lat]);
                    const polyline = new AMap.Polyline({
                        path: path,
                        strokeColor: '#000000',
                        strokeWeight: 5
                    });
                    map.add(polyline);
                    allPaths.push(polyline);
                }
            });

            map.setFitView([...allPaths, startMarker, endMarker]);
        }

        // ç»˜åˆ¶æ··åˆè·¯çº¿
        function drawMixedRoute(mixedRoute) {
            console.log('Drawing mixed route:', mixedRoute);

            // ç®€åŒ–ç‰ˆæœ¬:åªæ˜¾ç¤ºèµ·ç»ˆç‚¹è¿çº¿,å› ä¸ºæˆ‘ä»¬æ²¡æœ‰ä¿å­˜å®Œæ•´è·¯å¾„æ•°æ®
            // åœ¨å®é™…åº”ç”¨ä¸­,åº”è¯¥ä¿å­˜æ¯æ®µçš„å®Œæ•´è·¯å¾„ä¿¡æ¯
            const path = [
                [startLocation.lng, startLocation.lat],
                [endLocation.lng, endLocation.lat]
            ];

            const polyline = new AMap.Polyline({
                path: path,
                strokeColor: '#FF6B00',  // æ©™è‰²è¡¨ç¤ºæ··åˆæ–¹æ¡ˆ
                strokeWeight: 5,
                strokeOpacity: 0.8,
                strokeStyle: 'solid'
            });

            map.add(polyline);
            map.setFitView([polyline, startMarker, endMarker]);
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing...');
            initMap();
            checkStatus();
            setInterval(checkStatus, 30000);

            document.getElementById('route-form').addEventListener('submit', planRoute);
        });
    </script>
</body>
</html>
